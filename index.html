<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>ksm by asamy</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>ksm</h1>
        <h2>A really simple and lightweight x64 hypervisor written in C for Windows (Intel processors).  Supports VMFUNC, EPTP switching, #VE EPT Violation and IDT shadowing.  VMFUNC backward compatibility also supported.</h2>

        <section id="downloads">
          <a href="https://github.com/asamy/ksm/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/asamy/ksm/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/asamy/ksm" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a id="ksm-" class="anchor" href="#ksm-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ksm <a href="https://travis-ci.org/asamy/ksm"><img src="https://travis-ci.org/asamy/ksm.svg?branch=master" alt="Build Status"></a>
</h1>

<p><a href="https://scan.coverity.com/projects/asamy-ksm">
  <img alt="Coverity Scan Build Status" src="https://scan.coverity.com/projects/10823/badge.svg">
</a></p>

<p>A really simple and lightweight x64 hypervisor written in C for Intel processors.</p>

<h2>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Features</h2>

<ul>
<li>IDT Shadowing</li>
<li>EPT violation #VE (if not available natively, it will keep using VM-Exit instead)</li>
<li>EPTP switching VMFUNC (if not available natively, it will be emulated using a VMCALL)</li>
</ul>

<h2>
<a id="why-not-other-hypervisors" class="anchor" href="#why-not-other-hypervisors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why not other hypervisors?</h2>

<p>You may have already guessed from the <code>Features</code> part, if not, here are some reasons:</p>

<ul>
<li>Do not implement the new processor features KSM implements (VMFUNC, #VE, etc.)</li>
<li>Are not simple enough to work with or understand</li>
<li>Simply, just have messy code base or try too hard to implement endless C++ features that just make code ugly.</li>
<li>Too big code base and do not have the same purpose (e.g. research or similar)</li>
</ul>

<p>Such features for such purpose is really crucial, for my purpose, I wanted a quicker physical memory virtualization
technique that I can relay on.</p>

<h2>
<a id="requirements" class="anchor" href="#requirements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Requirements</h2>

<ul>
<li>An Intel processor</li>
<li>A working C compiler (GCC or CLang or Microsoft compiler (CL)).  You can use VS 2015.</li>
</ul>

<h2>
<a id="compiling-under-mingw" class="anchor" href="#compiling-under-mingw" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Compiling under MinGW</h2>

<p>Simply <code>make C=1</code> (if cross compiling under Linux) or <code>mingw32-make</code> (under MinGW).</p>

<h2>
<a id="unsupported-features-hardware-etc" class="anchor" href="#unsupported-features-hardware-etc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Unsupported features (hardware, etc.)</h2>

<ul>
<li>UEFI</li>
<li>Intel TXT</li>
<li>VT-x nesting (i.e. having a vm running inside it not the other way around!)</li>
</ul>

<h2>
<a id="debugging-andor-testing" class="anchor" href="#debugging-andor-testing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Debugging and/or testing</h2>

<p>Since #VE and VMFUNC are now optional and will not be enabled unless the CPU support it, you can now test under VMs with
emulation for VMFUNC.</p>

<h2>
<a id="supported-kernels" class="anchor" href="#supported-kernels" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Supported Kernels</h2>

<p>All x64 NT kernels starting from the Windows 7 NT kernel.  It was mostly tested under Windows 7/8/8.1/10.</p>

<h2>
<a id="porting-to-other-kernels-eg-linux-or-similar-guidelines" class="anchor" href="#porting-to-other-kernels-eg-linux-or-similar-guidelines" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Porting to other kernels (e.g. Linux or similar) guidelines</h2>

<ul>
<li>Port <code>mm.h</code> functions (<code>mm_alloc_pool, mm_free_pool, __mm_free_pool</code>).  You'll need <code>__get_free_page</code> instead of <code>ExAllocatePool</code>.</li>
<li>Port <code>acpi.c</code> (not really needed) for re-virtualization on S1-3 or S4 state (commenting it out is OK).</li>
<li>Port <code>main.c</code> for some internal windows stuff, e.g. <code>DriverEntry</code>, etc.  Perhaps even rename to something like main_windows.c or similar.</li>
<li>Port <code>page.c</code> for the hooking example (not required, but it's essential to demonstrate usage).</li>
</ul>

<p>Hopefully didn't miss something important, but these are definitely the mains.</p>

<h2>
<a id="contributions" class="anchor" href="#contributions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contributions</h2>

<p>Contributions are really appreciated and can be submitted by one of the following:</p>

<ul>
<li>Patches (e-mail)</li>
<li>Github pull requests</li>
<li>git request-pull</li>
</ul>

<p>It'd be appreciated if you use a separate branch for your submissions (other than master, that is).</p>

<h2>
<a id="todo--in-consideration" class="anchor" href="#todo--in-consideration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TODO / In consideration</h2>

<ul>
<li>APIC virtualization (Partially implemented)</li>
<li>MMIO (Partially implemented)</li>
<li>UEFI support</li>
<li>Intel TXT support</li>
<li>Nesting support (Partially implemented)</li>
<li>Interrupt queueing (currently if an injection fails, it will just ignore it, should be simple).</li>
</ul>

<h2>
<a id="loading-the-driver" class="anchor" href="#loading-the-driver" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Loading the driver</h2>

<p>In commandline as administrator:</p>

<ol>
<li><code>sc create ksm type= kernel binPath= C:\path\to\your\ksm.sys</code></li>
<li><code>sc start ksm</code></li>
</ol>

<p>Unloading:
<code>sc stop ksm</code></p>

<p>Note: KSM is provided unsigned, that means, you might need to enable Testsigning to be able to load the driver.  KSM does not have a binary distributed publicly, you'll have to compile it yourself.
You can also use <a href="https://github.com/asamy/kload">kload</a></p>

<h2>
<a id="technical-information" class="anchor" href="#technical-information" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Technical information</h2>

<p>Note: If the processor does not support VMFUNC or #VE, they will be disabled and instead, emulated via VM-exit.</p>

<h3>
<a id="idt-shadowing" class="anchor" href="#idt-shadowing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>IDT shadowing</h3>

<ul>
<li>By enabling the descriptor table exiting bit in processor secondary control, we can easily establish this</li>
<li>On initial startup, we allocate a completely new IDT base and copy the current one in use to it (also save the old
                                               one)</li>
<li>When a VM-exit occurs with an <code>EXIT_REASON_GDT_IDT_ACCESS</code>, we simply just give them the cached one (on sidt) or (on
                                                      lidt),
we copy the new one's contents, discarding the hooked entries we know about, thus not letting them know about
our stuff.</li>
</ul>

<h3>
<a id="ve-setup-and-handling" class="anchor" href="#ve-setup-and-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>#VE setup and handling</h3>

<p>We use 3 EPT pointers, one for executable pages, one for readwrite pages, and last one for normal usage.  (see next
                                                       section)</p>

<ul>
<li><p><code>vcpu.c</code>: in <code>setup_vmcs()</code> where we initially setup the VMCS fields, we then set the relevant fields (<code>VE_INFO_ADDRESS</code>,
                                                <code>EPTP_LIST_ADDRESS</code>,
                                                <code>VM_FUNCTION_CTL</code>) and enable
relevant bits VE and VMFUNC in secondary processor control.</p></li>
<li><p><code>x64.asm</code> (or <code>x64.S</code> for GCC): which contains the <code>#VE</code> handler (<code>__ept_violation</code>) then does the usual interrupt handling and then calls
<code>__ept_handle_violation</code> (<code>ept.c</code>) where it actually does what it needs to do.</p></li>
<li>
<code>ept.c</code>: in <code>__ept_handle_violation</code> (<code>#VE</code> handler <em>not</em> <code>VM-exit</code>), usually the processor will do the <code>#VE</code> handler instead of
the VM-exit route, but sometimes it won't do so if it's delivering another exception.  This is very rare.</li>
<li>
<code>ept.c</code>: while handling the violation via <code>#VE</code>, we call <code>vmfunc</code> only when we detect that the faulting address is one of
our interest (e.g. a hooked page), then we determine which <code>EPTP</code> we want and execute <code>VMFUNC</code> with that EPTP index.</li>
</ul>

<h3>
<a id="hooking-executable-pages" class="anchor" href="#hooking-executable-pages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hooking executable pages</h3>

<h4>
<a id="execute-only-ept-for-executable-page-hooking-rw-for-read-or-write-access" class="anchor" href="#execute-only-ept-for-executable-page-hooking-rw-for-read-or-write-access" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Execute-only EPT for executable page hooking, RW for read or write access</h4>

<pre><code>(... to avoid a lot of violations, we just mark the page as execute only and replace the _final_ page frame
 number so that it just goes straight ahead to our trampoline)
</code></pre>

<p>Since we use 3 EPT pointers, and since the page needs to be read and written to sometimes (e.g. patchguard
                                               verification),
      we also need to catch RW access to the page and then switch the EPTP appropriately according to
      the access.  In that case we switch over to <code>EPTP_RWHOOK</code> to allow RW access only!
    The third pointer is used for when we need to call the original function.</p>

<h2>
<a id="enabling-certain-features--tests" class="anchor" href="#enabling-certain-features--tests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Enabling certain features / tests</h2>

<p>You can define one or more of the following:</p>

<ul>
<li>
<code>RUN_TEST</code> - Runs a small MmMapIoSpace shadow hook test.</li>
<li>
<code>ENABLE_PML</code> - Enables Page Modification Log if supported.</li>
<li>
<code>EMULATE_VMFUNC</code> - Forces emulation of VMFUNC even if CPU supports it.</li>
<li>
<code>EPT_SUPPRESS_VE</code> - Force suppress VE bit in EPT.</li>
<li>
<code>ENABLE_ACPI</code> - Enable S1-3-S4 power state monitoring for re-virtualization</li>
<li>
<code>NESTED_VMX</code> - Enable experimental VT-x nesting</li>
</ul>

<h2>
<a id="reporting-bugs-or-similar" class="anchor" href="#reporting-bugs-or-similar" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reporting bugs (or similar)</h2>

<p>You can report bugs by using Github issues, please provide the following:</p>

<ul>
<li>System information (version including build number, CPU information perhaps codename too)</li>
<li>The git tree hash</li>
<li>Anything else you feel is relevant</li>
</ul>

<p>If it's a crash, please provide the following:</p>

<ul>
<li>A minidump (C:\windows\minidump) or a memory dump (C:\windows\memory.dmp).  Former prefered.</li>
<li>The compiled .sys and the .pdb/.dbg file</li>
<li>The Kernel executable if possible, e.g. ntoskrnl.exe from C:\Windows\System32</li>
</ul>

<h2>
<a id="thanks-to" class="anchor" href="#thanks-to" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Thanks to...</h2>

<ul>
<li>Linux kernel (KVM)</li>
<li>HyperPlatform</li>
</ul>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h2>

<p>GPL v2 firm, see LICENSE file.</p>

<pre><code>    ksm - a really simple and fast x64 hypervisor
    Copyright (C) 2016 Ahmed Samy &lt;f.fallen45@gmail.com&gt;

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
</code></pre>
      </section>
    </div>

    
  </body>
</html>
